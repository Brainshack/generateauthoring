using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerator;

[Generator]
public class AuthoringCodeGenerator: IIncrementalGenerator
{
    private string _attributeSourceCode = @"// <auto-generated/>

namespace Generators
{
    [System.AttributeUsage(System.AttributeTargets.Struct)]
    internal class GenerateAuthoringAttribute : System.Attribute
    {
    }
}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateAuthoringAttribute.g.cs",
            SourceText.From(_attributeSourceCode, Encoding.UTF8)));
        
        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is StructDeclarationSyntax,
                (ctx, _) => GetDeclarationForSourceGen(ctx))
            .Where(t => t.attributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private void GenerateCode(SourceProductionContext ctx, Compilation compilation, ImmutableArray<StructDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            // Go through all class members with a particular type (property) to generate method lines.
            var authoringBody = classSymbol.GetMembers()
                .OfType<IFieldSymbol>()
                .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                .Select(p =>
                    $@"        public {p.Type.ToDisplayString()} {p.Name};"); // e.g. yield return $"Id:{this.Id}";
            
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;
            
            var code = $@"using Unity.Entities;
using UnityEngine;

namespace {namespaceName}
{{
    [UnityEngine.AddComponentMenu(""Authoring/{className} Authoring"")]
    internal class {className}Authoring : MonoBehaviour
    {{
{string.Join("\n", authoringBody)}
    }}
}}";
            
            ctx.AddSource($"{className}Authoring.g.cs", SourceText.From(code, Encoding.UTF8));
            
        }
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [GenerateAuthoring] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (StructDeclarationSyntax, bool attributeFound) GetDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (StructDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                    continue; // if we can't get the symbol, ignore it

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the attribute.
                if (attributeName == $"Generators.GenerateAuthoringAttribute")
                    return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }
}